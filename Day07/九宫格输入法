先说题意，这个题的意思是手机中的九宫格输入法，每一个数字对应着许多字母。

题目给了n个数字的组合，又给出了m组字母，然后让你用这些数字对这些字母进行匹配，问每一个数字最多能匹配多少个字母.

我们先把每一个由字母组成的字符串转换成数字，然后插入在字典树中，然后直接查询对应的数字就可以了
#include <cstdio>
#include <cstring>
#include <string>
#include <set>
#include <sstream>
#include <cmath>
#include <iostream>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#define mem(a,b) memset(a,b,sizeof(a))
#define inf 0x3f3f3f3f
#define debug() puts("what the fuck!!!")
#define ll long long
using namespace std;
const int N=5020*6;
string num[N];
int n,m;
int change(char ch)
{
    if(ch=='a'||ch=='b'||ch=='c')
        return 2;
    else if(ch=='d'||ch=='e'||ch=='f')
        return 3;
    else if(ch=='g'||ch=='h'||ch=='i')
        return 4;
    else if(ch=='j'||ch=='k'||ch=='l')
        return 5;
    else if(ch=='m'||ch=='n'||ch=='o')
        return 6;
    else if(ch=='p'||ch=='q'||ch=='r'||ch=='s')
        return 7;
    else if(ch=='t'||ch=='u'||ch=='v')
        return 8;
    else
        return 9;
}
struct dicTree
{
    struct node
    {
        int sum;
        int next[10];
    } Tree[N];
    int root,sz;
    int newnode()
    {
        for(int i=0; i<10; i++)
            Tree[sz].next[i]=-1;
        Tree[sz++].sum=0;
        return sz-1;
    }
    void init()
    {
        sz=0;
        root=newnode();
    }
    void insert(string s)
    {
        int now=root;
        int len=s.length();
        for(int i=0; i<len; i++)
        {
            int to=change(s[i]);
            if(Tree[now].next[to]==-1)
                Tree[now].next[to]=newnode();
            now=Tree[now].next[to];
        }
        Tree[now].sum++;
    }
    int find(string s)
    {
        int now=root;
        int len=s.length();
        for(int i=0; i<len; i++)
        {
            int to=s[i]-'0';
            if(Tree[now].next[to]==-1)
                return 0;
            now=Tree[now].next[to];
        }
        return Tree[now].sum;
    }

};
dicTree T;
string s;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        T.init();
        scanf("%d%d",&n,&m);
        for(int i=1; i<=n; i++)
            cin>>num[i];
        for(int i=1; i<=m; i++)
        {
            cin>>s;
            T.insert(s);
        }
        for(int i=1; i<=n; i++)
            cout<<T.find(num[i])<<endl;
    }
    return 0;
}

map版：
#include <bits/stdc++.h>
using namespace std;
const int N=5020*6;
string num[N];
int n,m;
map<string,int>mp;
char change(char ch)
{
    if(ch=='a'||ch=='b'||ch=='c')
        return '2';
    else if(ch=='d'||ch=='e'||ch=='f')
        return '3';
    else if(ch=='g'||ch=='h'||ch=='i')
        return '4';
    else if(ch=='j'||ch=='k'||ch=='l')
        return '5';
    else if(ch=='m'||ch=='n'||ch=='o')
        return '6';
    else if(ch=='p'||ch=='q'||ch=='r'||ch=='s')
        return '7';
    else if(ch=='t'||ch=='u'||ch=='v')
        return '8';
    else
        return '9';
}
string calc(string s)
{
    string ans="";
    int len=s.length();
    for(int i=0; i<len; i++)
        ans+=change(s[i]);
    return ans;
}
string s;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        mp.clear();
        scanf("%d%d",&n,&m);
        for(int i=1; i<=n; i++)
            cin>>num[i];
        for(int i=1; i<=m; i++)
        {
            cin>>s;
            mp[calc(s)]++;
        }
        for(int i=1; i<=n; i++)
            cout<<mp[num[i]]<<endl;
    }
    return 0;
}
